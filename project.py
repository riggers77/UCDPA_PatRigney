# -*- coding: utf-8 -*-
"""Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ecK0X1JQwn363OBIAeNQ_5jd3tDzfbXp
"""

# Import numpy as np, pandas as pd, matplotlib as plt, seaborn as sns, requests and beautifulsoup as bs
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import requests
from bs4 import BeautifulSoup as bs

# Read World Population CSV file
World_Pop = pd.read_csv("https://github.com/riggers77/UCDPA_PatRigney/blob/main/World_Pop.csv?raw=True")

# Inspect first five rows of csv file
print(World_Pop.head())

# Read GDP Per Country CSV file
World_GDP = pd.read_csv("https://github.com/riggers77/UCDPA_PatRigney/blob/main/GDP_per_country.csv?raw=True")

# Inspect first five rows of GDP csv file
print(World_GDP.head())

# Use beautifulsoup to scrape the web for html code for table of countries by continent.
url="https://statisticstimes.com/geography/countries-by-continents.php"
r=requests.get(url)
html_doc = r.text
soup = bs(html_doc)
print(soup.prettify())

# find table in html and store as variable table
table = soup.find('table', id="table_id")

# convert to pandas DataFrame
table_df =  pd.read_html(str(table))[0]
table_df

# Set Country as index for Continenants DF
Continents=table_df.set_index('Country or Area')
print(Continents.head())

# Use beautifulsoup to scrap the web for html code for table of countries by alpha-2 and alpha-3 codes.
url2="https://www.iban.com/country-codes"
r2=requests.get(url2)
html_doc2=r2.text
soup2=bs(html_doc2)
print(soup2.prettify())

# find alphas-2 table in html and store as variable table
table_alpha=soup2.find('table', id="myTable")

# convert this alpha-2 table to pandas DataFrame
table_df_alpha= pd.read_html(str(table_alpha))[0]
table_df_alpha

# Read World Population CSV file
World_HPI= pd.read_csv("https://github.com/riggers77/UCDPA_PatRigney/blob/main/House_Price_Index.csv?raw=True")

# Inspect first five rows of csv file
print(World_HPI.head())

# Clean DataFrame World_HPI by removing unwanted columns
World_HPI_by_Country_Cleaned=World_HPI.iloc[:, [5,6,7]]
World_HPI_by_Country_Cleaned=World_HPI_by_Country_Cleaned.rename(columns={'geo': 'Alpha-2 code', 'TIME_PERIOD':'Year'})
print(World_HPI_by_Country_Cleaned.head())
World_HPI_by_Country_Cleaned.shape

# Merge World_HPI_by_Country_Cleaned DF with table_df_alpha DF on Alpha-2 code using a left merge and rename columns Alpha-3 code and OBS_Value
HPI_Country_Code = World_HPI_by_Country_Cleaned.merge(table_df_alpha, on='Alpha-2 code', how='left')
HPI_Country_Code=HPI_Country_Code.rename(columns={'Alpha-3 code':'Country Code', 'OBS_VALUE':'HPI'})
print(HPI_Country_Code.head())
HPI_Country_Code.shape

# Create List of Years in Scope
Years_in_Scope=[str('Country Name'),str("Country Code"),"2005", "2006",	"2007",	"2008",	"2009",	"2010",	"2011",	"2012",	"2013",	"2014",	"2015",	"2016",	"2017",	"2018",	"2019"]

# Slice DataFrame to only include the years in scope data for World Population
World_Pop_cleaned=World_Pop.loc[:, Years_in_Scope]

# Slice DataFrame to only include the years in scope data for World GDP
World_GDP_cleaned = World_GDP.loc[:, Years_in_Scope]
print(World_GDP_cleaned)

# Clean DataFrame Continents to remove unwanted columns
Continent_Cleaned = Continents.iloc[:, [1,3,5]]
print(Continent_Cleaned.head())

# Rename ISO Alpha3 Code Column to Country Code
Continent_Cleaned=Continent_Cleaned.rename(columns={'ISO-alpha3 Code' : 'Country Code'})
print(Continent_Cleaned)

# Merge Continents Column in Continent_Cleaned DataFrame with World_Pop_Per_country_cleaned DataFrame
Merge_Population = World_Pop_cleaned.merge(Continent_Cleaned, on='Country Code', how='left')
print(Merge_Population)

# Clean the DataFrame Merge_Population so all NaN rows are dropped as they do not relate to countries but regions within the Country field for World_Pop data set
Merge_Pop_Cleaned=Merge_Population.dropna()
print(Merge_Pop_Cleaned)

# Reshape the DF Merge_Population using melt to have all columns relating to years be in one column against Country, Country code, Region and Continent
Pop_Cleaned_Reshaped = Merge_Pop_Cleaned.melt(id_vars=['Country Name', 'Country Code', 'Region 1', 'Continent'])

# Rename the variable and value column that is created from the output of the reshape to a more understandable context ie Year and Population
Pop_Columns_Updated=Pop_Cleaned_Reshaped.rename(columns={'variable':'Year', 'value':'Population'})
print(Pop_Columns_Updated)

# Reshape the DF World_GDP_cleaned using melt to have all columns relating to years be in one column against Country and country Code
World_GDP_Reshaped = World_GDP_cleaned.melt(id_vars=['Country Name', 'Country Code'])

# Rename the variable and value column that is created from the output of the reshape to a more understandable context ie Year and GDP
World_GDP_Columns_Updated=World_GDP_Reshaped.rename(columns={'variable':'Year', 'value':'GDP'})
print(World_GDP_Columns_Updated)
World_GDP_Columns_Updated.to_csv('/content/drive/MyDrive/Colab Notebooks/World_GDP_Columns_Updated.csv')

# Merge the DF Pop_Columns_Update and World_GDP_Columns_Updated on a left join on Country Code so all records for Pop_Columns_Update are returned along with related columns from World_GDP_Columns_Updated
Merge_Pop_GDP = Pop_Columns_Updated.merge(World_GDP_Columns_Updated, on=['Country Code', 'Year'], how='left', suffixes=('_pop', '_gdp'))
print(Merge_Pop_GDP)
Merge_Pop_GDP.isna().any()

# Fill any missing data with the previous years missing data for GDP as it is the only column with missing data
Merge_Pop_GDP.sort_values(['Country Name_pop', 'Year'])
Pop_GDP_Fill_Missing_Values= Merge_Pop_GDP.fillna(method='ffill')
print(Pop_GDP_Fill_Missing_Values)
Pop_GDP_Fill_Missing_Values.shape
Pop_GDP_Fill_Missing_Values.to_csv('/content/drive/MyDrive/Colab Notebooks/Pop_GDP_Fill_Missing_Values.csv')

# Clean the DF HPI_Country_Code by removing null values as they do not represent countries
HPI_Country_Code_Cleaned=HPI_Country_Code.dropna()
print(HPI_Country_Code_Cleaned)
HPI_Country_Code_Cleaned.to_csv('/content/drive/MyDrive/Colab Notebooks/HPI_Country_Code_Cleaned.csv')

# Convert Year column in Pop_GDP_Missing_Values to integer type as after being used as a merge column for two DF it became an object and would provide an error on next step of merging
Pop_GDP_Fill_Missing_Values['Year']=Pop_GDP_Fill_Missing_Values['Year'].astype(int)

# Merge DFs Pop_GDP_Fill_Missing_Values and HPI_Country_Code
Pop_GDP_HPI_Years=Pop_GDP_Fill_Missing_Values.merge(HPI_Country_Code_Cleaned, on=['Country Code', 'Year'], how='left')
Pop_GDP_HPI_Years.shape
print(Pop_GDP_HPI_Years)
Pop_GDP_HPI_Years.to_csv('/content/drive/MyDrive/Colab Notebooks/Pop_GDP_HPI_Years.csv')

# Find what values are missing and what part of the dataset has a working dataset using the continent as the group argument
Pop_GDP_HPI_Years.groupby(by=['Continent'], dropna=True).count()

# As Europe has the closest complete set of data I will use Europe as my dataset. I will use numpy and comparators to filter my data frame to just show Europe countries
Eur_DF = Pop_GDP_HPI_Years[np.logical_and(Pop_GDP_HPI_Years['Continent']=='Europe', Pop_GDP_HPI_Years['Year']>2009)]
print(Eur_DF)

# Find what values are missing and what part of the dataset has a working dataset using the continent as the group argument
Eur_DF.groupby(by=['Country Name_pop'], dropna=True).count()

# All missing values relate to countries that have no HPI values for the complete time period so I am going to drop these values from the Data set
Eur_DF_Cleaned = Eur_DF.dropna()
print(Eur_DF_Cleaned)
Eur_DF_Cleaned.to_csv('/content/drive/MyDrive/Colab Notebooks/Eur_DF_Cleaned.csv')

# See how many countries are in scope
Eur_DF_Cleaned['Country Name_pop'].nunique()

# Create a new column to show GDP per captia ie GDP divide by population
Eur_DF_Cleaned['GDP Per Capita'] = Eur_DF_Cleaned['GDP Per Capita']= Eur_DF_Cleaned['GDP'] / Eur_DF_Cleaned['Population']

# Base line the Countries Prosperiy by taking the latest years GDP per captia figure
Current_Countries_GDP = Eur_DF_Cleaned.loc[Eur_DF_Cleaned['Year']==2019]

# Show the Top 9 Prosperous Countries
Current_Countries_GDP.nlargest(9,['GDP Per Capita'])

# Find the min value for GDP Per Captial for the Top 9 Prosperous Countries (9 is used as we have 27 countries I want to divide them into 3 categories)
Value_for_largest= Current_Countries_GDP.nlargest(9,['GDP Per Capita'])
print(Value_for_largest['GDP Per Capita'].min())

# Get a series of countries that are the top 9 prosperous countries
Largest_GDP=Current_Countries_GDP.nlargest(9,['GDP Per Capita'])
Largest_GDP_Countries=Largest_GDP['Country Name_pop']
type(Largest_GDP_Countries)

# Get the next 9 countries that are prosperous to see the 18th value for GDP per Captia
Current_Countries_GDP.nlargest(18,['GDP Per Capita'])

# Find the value of the 18th prosperous country for 2019
Value_for_medium=Current_Countries_GDP.nlargest(18,['GDP Per Capita'])
print(Value_for_medium['GDP Per Capita'].min())

# Get a series of countries that are the next 9 in the second tier of prosperous countries. This will be countries between the two values we received in the previous code
Medium_GDP=Current_Countries_GDP[np.logical_and(Current_Countries_GDP['GDP Per Capita']<48717.71002856777, Current_Countries_GDP['GDP Per Capita']>=23519.7767588998)]
Medium_GDP_Countries=Medium_GDP['Country Name_pop']
print(Medium_GDP_Countries.tolist())

# Create a for loop that will create a new column called category and iterate through the data frame and populate the new column with one of 3 categories depending if the country is in largest or medium series created above or not.
Category = []
for C in Eur_DF_Cleaned['Country Name_pop']:
  if C in Largest_GDP_Countries.tolist():
    Category.append('Largest GDP Countries')
  elif C in Medium_GDP_Countries.tolist():
    Category.append('Medium GDP Countries')
  else:
    Category.append('Smallest GDP Countries')
Eur_DF_Cleaned['Category']=Category
print(Eur_DF_Cleaned)
Eur_DF_Cleaned.to_csv('/content/drive/MyDrive/Colab Notebooks/Eur_DF_Cleaned.csv')

# Index the final Data Frame with Country Name as the index
Eur_final_data = Eur_DF_Cleaned.set_index(['Country Name_pop'])
print(Eur_final_data)
Eur_final_data.to_csv('/content/drive/MyDrive/Colab Notebooks/Eur_final_data.csv')

# Created a column to show the % increase in Population from oringinal figure in 2010 against the last figure in 2019
Pop_column_2010= pd.DataFrame(Eur_final_data)
Pop_column_2010=Pop_column_2010.loc[Pop_column_2010['Year']==2010]
Pop_column_2019= pd.DataFrame(Eur_final_data)
Pop_column_2019=Pop_column_2019.loc[Pop_column_2019['Year']==2019]
Eur_final_data['Pop in 2010']=Pop_column_2010['Population']
Eur_final_data['Pop in 2019']=Pop_column_2019['Population']
Eur_final_data['Pop Increase']= ((Eur_final_data['Pop in 2019'] - Eur_final_data['Pop in 2010']) / Eur_final_data['Pop in 2010'])*100
print(Eur_final_data)

# Created a column to show the % increase in GDP Per Capita from oringinal figure in 2010 against the last figure in 2019
GDP_Capita_column_2010= pd.DataFrame(Eur_final_data)
GDP_Capita_column_2010=GDP_Capita_column_2010.loc[GDP_Capita_column_2010['Year']==2010]
GDP_Capita_column_2019= pd.DataFrame(Eur_final_data)
GDP_Capita_column_2019=GDP_Capita_column_2019.loc[GDP_Capita_column_2019['Year']==2019]
Eur_final_data['GDP Per Cap in 2010']=GDP_Capita_column_2010['GDP Per Capita']
Eur_final_data['GDP Per Cap in 2019']=GDP_Capita_column_2019['GDP Per Capita']
Eur_final_data['GDP Per Capita Increase']= ((Eur_final_data['GDP Per Cap in 2019'] - Eur_final_data['GDP Per Cap in 2010']) / Eur_final_data['GDP Per Cap in 2010'])*100
print(Eur_final_data)

# Created a column to show the % increase in HPI from oringinal figure in 2010 against the last figure in 2019
HPI_column_2010= pd.DataFrame(Eur_final_data)
HPI_column_2010=HPI_column_2010.loc[HPI_column_2010['Year']==2010]
HPI_column_2019= pd.DataFrame(Eur_final_data)
HPI_column_2019=HPI_column_2019.loc[HPI_column_2019['Year']==2019]
Eur_final_data['HPI in 2010']=HPI_column_2010['HPI']
Eur_final_data['HPI in 2019']=HPI_column_2019['HPI']
Eur_final_data['HPI Increase']= ((Eur_final_data['HPI in 2019'] - Eur_final_data['HPI in 2010']) / Eur_final_data['HPI in 2010']) *100
print(Eur_final_data)

# Created a column to show the % increase in GDP from oringinal figure in 2010 against the last figure in 2019
GDP_column_2010= pd.DataFrame(Eur_final_data)
GDP_column_2010=GDP_column_2010.loc[GDP_column_2010['Year']==2010]
GDP_column_2019= pd.DataFrame(Eur_final_data)
GDP_column_2019=GDP_column_2019.loc[GDP_column_2019['Year']==2019]
Eur_final_data['GDP in 2010']=GDP_column_2010['GDP']
Eur_final_data['GDP in 2019']=GDP_column_2019['GDP']
Eur_final_data['GDP Increase']= ((Eur_final_data['GDP in 2019'] - Eur_final_data['GDP in 2010']) / Eur_final_data['GDP in 2010']) * 100
print(Eur_final_data)
Eur_final_data.to_csv('/content/drive/MyDrive/Colab Notebooks/Eur_final_data.csv')

# Create a DataFrame to show the average growth in GDP Per Capita, HPI and Population over 10 year period - 2010 to 2019 for European Countries
Average_Growth_GDP=Eur_final_data.groupby(['Country Name_pop', 'Category'])[['GDP Per Capita', 'HPI', 'Population']].mean()
Average_Growth_GDP=Average_Growth_GDP.reset_index()
Average_Growth_GDP=Average_Growth_GDP.sort_values('GDP Per Capita', ascending=False)
print(Average_Growth_GDP)

# Using Seaborns relplot to line plot GDP Per Captia over time
g = sns.relplot(x='Year', y='GDP Per Capita', data=Eur_final_data, kind='line', hue='Country Name_pop')
plt.savefig('/content/drive/MyDrive/Colab Notebooks/countries_gdp_per_cap_growth.png')
g.fig.suptitle('GDP Per Capita over 10 year Period', y=1.05)
g.set(xlabel='2010 to 2019 Period', ylabel='GDP Per Capita')
plt.savefig('/content/drive/MyDrive/Colab Notebooks/GDP_Per_Cap_growth.png')
plt.show()

# Drill down into the data by subplotting on Region by category
Largest_GDP=pd.DataFrame(Eur_final_data)
Largest_GDP_with_timeseries=Largest_GDP.loc[Largest_GDP['Category']=='Largest GDP Countries']
sns.set_style('white')
g = sns.relplot(x='Year', y='GDP Per Capita', data=Largest_GDP_with_timeseries, kind='line', hue='Country Name_pop', col='Region 1')
g.fig.suptitle('GDP Per Capita over 10 year Period', y=1.05)
g.set(xlabel='2010 to 2019 Period', ylabel='GDP Per Capita')
plt.savefig('/content/drive/MyDrive/Colab Notebooks/Largest_count_gdp_per_cap_growth_by_region.png')
plt.show()

# Use Seaborn to get box plot to see the spread and how skewed is the data
Box_Df=pd.DataFrame(Eur_final_data)
Box_Df=Box_Df.loc[Box_Df['Year']==2019]
sns.set_palette('Blues')
sns.set_style('white')
g=sns.catplot(x='Region 1', y='GDP Increase', data=Box_Df, kind='box', hue='Category')
g.fig.suptitle('GDP Increase Per Region for Different levels of Prosperous Countries', y=1.05)
g.set(xlabel='Regions of Europe', ylabel='GDP Increase since 2010 figures')
plt.xticks(rotation=90)
plt.savefig('/content/drive/MyDrive/Colab Notebooks/Region_gdp_per_cap_%Increase_by_category.png')
plt.show()

# Seaborns bar plot used to subplot Average GDP Per Capita by category of country
sns.set_style('white')
g = sns.catplot(x='Country Name_pop', y='GDP Per Capita', data=Average_Growth_GDP, kind='bar', col='Category')
g.fig.suptitle('Avergage GDP Per Capita by Country over 10 years', y=1.05)
g.set_titles('These are {col_name} in 2019')
g.set(xlabel="Country", ylabel="Average GDP Per Capita Over 10 years")
g.set_xticklabels(rotation=90)
plt.show()

# Seaborns bar plot used to subplot Average HPI by category of country
sns.set_style('white')
g = sns.catplot(x='Country Name_pop', y='HPI', data=Average_Growth_GDP, kind='bar', col='Category')
type(g)
g.fig.suptitle('Avergage HPI by Country over 10 years', y=1.05)
g.set_titles('These are {col_name} in 2019')
g.set(xlabel="Country", ylabel="Average HPI Over 10 years")
g.set_xticklabels(rotation=90)
plt.show()

# Seaborn scatter plot to show GDP Per Capita V Population
sns.set_style('white')
g = sns.relplot(x="Population", y='GDP Per Capita', data=Eur_final_data, kind='scatter')
g.fig.suptitle('GDP Per Capita V Population', y=1.05)
g.set(xlabel="Population", ylabel="GDP Per Capita")
plt.show()

# Not in the report but used to show the col_order attribute
sns.set_style('white')
sns.relplot(x="GDP Increase", y='HPI Increase', data=Eur_final_data, kind='scatter', col='Category', col_wrap=2, col_order=['Largest GDP Countries', 'Medium GDP Countries', 'Smallest GDP Countries'])
plt.show()

# Not in the report but used to show historgram plot along with controlling color and transparencies
sns.set_style('white')
Largest_GDP=pd.DataFrame(Eur_final_data)
Largest_GDP=Largest_GDP[np.logical_and(Largest_GDP['Year']==2019, Largest_GDP['Category']=='Largest GDP Countries')]
Medium_GDP=pd.DataFrame(Eur_final_data)
Medium_GDP=Medium_GDP[np.logical_and(Medium_GDP['Year']==2019, Medium_GDP['Category']=='Medium GDP Countries')]
Smallest_GDP=pd.DataFrame(Eur_final_data)
Smallest_GDP=Smallest_GDP[np.logical_and(Smallest_GDP['Year']==2019, Smallest_GDP['Category']=='Smallest GDP Countries')]
fig, ax=plt.subplots()
ax.hist(Largest_GDP['GDP Increase'], label='Largest GDP', color='blue', alpha=0.2)
ax.hist(Medium_GDP['GDP Increase'], label='Medium GDP', color='yellow', alpha=0.2)
ax.hist(Smallest_GDP['GDP Increase'], label='Smallest GDP', color='r', alpha=0.2)
ax.set_xlabel('GDP Increase')
ax.set_ylabel('# of Countries')
ax.legend()
plt.show()